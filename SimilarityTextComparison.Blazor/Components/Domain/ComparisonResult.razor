@using SimilarityTextComparison.Blazor.Models
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Rendering
@using System.Text.Encodings.Web
@using SimilarityTextComparison.Domain.Models.Matching
@using SimilarityTextComparison.Domain.Models.TextPreProcessing

<div>
    @if (!string.IsNullOrEmpty(MyInputText1) && !string.IsNullOrEmpty(MyInputText2) && Tokens != null && Tokens.Any() && Results != null && Results.Any())
    {
        @* Il rendering dipende dal RenderTextIndex *@
        @if (RenderTextIndex == 0)
        {
            <h5>Testo 1 (con evidenziazioni)</h5>
            <div>@(RenderHighlightedText(MyInputText1, Tokens, Results, 0))</div>
        }
        else if (RenderTextIndex == 1)
        {
            <h5>Testo 2 (con evidenziazioni)</h5>
            <div>@(RenderHighlightedText(MyInputText2, Tokens, Results, 1))</div>
        }
    }
    else
    {
        <p>Nessun risultato da mostrare.</p>
    }
</div>

@code {
    [Parameter]
    public List<List<MatchSegment>> Results { get; set; }

    [Parameter]
    public List<Token> Tokens { get; set; }

    // Entrambi i testi originali
    [Parameter]
    public string MyInputText1 { get; set; }

    [Parameter]
    public string MyInputText2 { get; set; }

    [Parameter]
    public int RenderTextIndex { get; set; } // 0 o 1

    /// <summary>
    /// Genera una stringa HTML con i match evidenziati.
    /// </summary>
    private MarkupString RenderHighlightedText(string fullText, List<Token> allTokens, List<List<MatchSegment>> allMatches, int textIndex)
    {
        if (string.IsNullOrEmpty(fullText) || allTokens == null || allTokens.Count == 0)
            return (MarkupString)$"<pre>{fullText}</pre>";

        // Raccogli tutti i MatchSegment relativi a questo textIndex
        var segments = allMatches
            // Ogni sottolista di solito ha [0]=MatchSegment testo sorgente, [1]=MatchSegment testo destinazione
            // ...oppure viceversa, a seconda di come è impostata la pipeline
            // Li “flatteniamo” e filtriamo per textIndex
            .SelectMany(subList => subList)
            .Where(ms => ms.TextIndex == textIndex)
            .OrderBy(ms => ms.TokenBeginPosition)
            .ThenByDescending(ms => ms.MatchLength)
            .ToList();

        if (!segments.Any())
            return (MarkupString)$"<pre>{System.Net.WebUtility.HtmlEncode(fullText)}</pre>";

        var sb = new System.Text.StringBuilder();
        int currentPos = 0;

        foreach (var seg in segments)
        {
            // Ottieni le coordinate in termini di caratteri
            int segStart = seg.GetTxtBeginPos(allTokens);
            int segEnd = seg.GetTxtEndPos(allTokens);

            // Controllo di bounds
            if (segStart < 0 || segEnd > fullText.Length || segStart > segEnd)
                continue;

            // Aggiungi la parte di testo "non evidenziata" immediatamente precedente
            if (currentPos < segStart)
            {
                var normalChunk = fullText.Substring(currentPos, segStart - currentPos);
                sb.Append(System.Net.WebUtility.HtmlEncode(normalChunk));
            }

            // Crea l'elemento evidenziato
            var matchChunk = fullText.Substring(segStart, segEnd - segStart);
            sb.Append($"<span class=\"{System.Net.WebUtility.HtmlEncode(seg.StyleClass ?? "highlight")}\">");
            sb.Append(System.Net.WebUtility.HtmlEncode(matchChunk));
            sb.Append("</span>");

            // Aggiorna l'indice corrente
            currentPos = segEnd;
        }

        // Aggiungi l'eventuale parte finale di testo dopo l'ultimo match
        if (currentPos < fullText.Length)
        {
            var tail = fullText.Substring(currentPos);
            sb.Append(System.Net.WebUtility.HtmlEncode(tail));
        }

        return new MarkupString(sb.ToString());
    }
}