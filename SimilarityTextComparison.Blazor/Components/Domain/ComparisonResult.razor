@using SimilarityTextComparison.Domain.Models.Matching
@using SimilarityTextComparison.Domain.Models.TextPreProcessing

<div>
    @if (!string.IsNullOrEmpty(MyInputText1) && !string.IsNullOrEmpty(MyInputText2) && Tokens != null && Tokens.Any() && Results != null && Results.Any())
    {
        <h5>Testo 1 (con evidenziazioni)</h5> <div>@(HighlightText(0, MyInputText1, Tokens, Results))</div>
        <h5>Testo 2 (con evidenziazioni)</h5>
        <div>@(HighlightText(1, MyInputText2, Tokens, Results))</div>
    }
    else
    {
        <p>Nessun risultato da mostrare.</p>
    }
</div>
@code {
    [Parameter]
    public List<List<MatchSegment>> Results { get; set; }

    [Parameter]
    public List<Token> Tokens { get; set; }

    // Entrambi i testi originali
    [Parameter]
    public string MyInputText1 { get; set; }

    [Parameter]
    public string MyInputText2 { get; set; }

    /// <summary>
    /// Genera un MarkupString dell’intero testo con gli highlight dei match.
    /// Implementa la stessa filosofia (semplificata) del codice JS:
    /// - Raccoglie i segmenti per textIndex
    /// - Li ordina
    /// - Ricompone il testo con i tag evidenziati
    /// </summary>
    private MarkupString HighlightText(int textIndex, string fullText,
        List<Token> allTokens, List<List<MatchSegment>> allMatches)
    {
        if (string.IsNullOrEmpty(fullText) || allTokens == null || allTokens.Count == 0)
            return (MarkupString)$"<pre>{fullText}</pre>";

        // Prende tutti i MatchSegment relativi a questo textIndex
        var segments = allMatches
            // Ogni sotto-lista di solito ha [0]=MatchSegment testo sorgente, [1]=MatchSegment testo destinazione
            // ...oppure viceversa, a seconda di come è impostata la pipeline
            // Li “flatteniamo” e filtriamo per textIndex
            .SelectMany(subList => subList)
            .Where(ms => ms.TextIndex == textIndex)
            .ToList();

        if (!segments.Any())
            return (MarkupString)$"<pre>{fullText}</pre>";

        // Ordina i segmenti per posizione di inizio (ascendente)
        // Se la pipeline ha già gestito overlap/merge, dovrebbero essere “puliti”.
        // Altrimenti potresti dover filtrare o tagliare le sovrapposizioni manualmente.
        segments = segments
            .OrderBy(m => m.TokenBeginPosition)
            .ThenByDescending(m => m.MatchLength)
            .ToList();

        // Costruisce una stringa HTML con highlight/spans
        // Scorriamo a “blocchi” dall’ultima fine evidenziata al nuovo inizio
        // e poi ci inseriamo <span> con la parte matchata.
        int currentCharIndex = 0;
        var sb = new System.Text.StringBuilder();

        foreach (var seg in segments)
        {
            // ottieni le coordinate in termini di caratteri
            int segStart = seg.GetTxtBeginPos(allTokens);
            int segEnd = seg.GetTxtEndPos(allTokens);

            // Fai un controllo di bounds
            if (segStart < 0 || segEnd >= fullText.Length || segStart > segEnd)
                continue;

            // Aggiungi la parte di testo "non evidenziata" subito precedente
            if (currentCharIndex < segStart)
            {
                var normalSlice = fullText.Substring(currentCharIndex, segStart - currentCharIndex);
                sb.Append(System.Net.WebUtility.HtmlEncode(normalSlice));
            }

            // Aggiungi la parte evidenziata
            var matchSlice = fullText.Substring(segStart, segEnd - segStart + 1);
            // Se vuoi i link “incrociati” come nel JS (es. href al match corrispondente)
            // puoi usare seg.CreateLinkNode(...), ma devi recuperare l'eventuale match "targetSegment".
            // In forma semplice, usiamo uno <span> con classe highlight:
            sb.Append($"<span class=\"{System.Net.WebUtility.HtmlEncode(seg.StyleClass ?? "highlight")}\">");
            sb.Append(System.Net.WebUtility.HtmlEncode(matchSlice));
            sb.Append("</span>");

            // Aggiornamento dell’indice
            currentCharIndex = segEnd + 1;
        }

        // Aggiunge l’eventuale parte finale (dopo l’ultimo match)
        if (currentCharIndex < fullText.Length)
        {
            var tail = fullText.Substring(currentCharIndex);
            sb.Append(System.Net.WebUtility.HtmlEncode(tail));
        }

        // Ritorna la stringa finale sotto forma di MarkupString
        return new MarkupString(sb.ToString());
    }
}