@using SimilarityTextComparison.Domain.Models.Matching
@using SimilarityTextComparison.Domain.Models.TextPreProcessing

@if (Results != null && Results.Any())
{
	@foreach (var match in Results)
	{
		<div class="card mb-3">
			<div class="card-body">
				<p class="card-text">
					<strong>Testo @(match.TextIndex + 1):</strong>
					@((MarkupString)GetHighlightedText(match, Tokens))
				</p>
			</div>
		</div>
	}
}
else
{
	<p>Nessun risultato da mostrare.</p>
}

@code {
	[Parameter]
	public List<MatchSegment> Results { get; set; }

	[Parameter]
	public List<Token> Tokens { get; set; }

	[Parameter]
	public string MyInputText1 { get; set; }

	[Parameter]
	public string MyInputText2 { get; set; }

	private string GetHighlightedText(MatchSegment match, List<Token> tokens)
	{
		if (match == null || tokens == null || tokens.Count == 0)
			return string.Empty;

		int startPos = match.GetTxtBeginPos(tokens);
		int endPos = match.GetTxtEndPos(tokens);
		string originalText = GetOriginalText(match.TextIndex);

		if (string.IsNullOrEmpty(originalText) || 
		// Gestione degli indici per evitare errori
		    startPos < 0 || endPos >= originalText.Length || startPos > endPos)
		{
			return originalText ?? string.Empty;
		}

		string matchedText = originalText.Substring(startPos, endPos - startPos + 1);

		// Avvolge il testo corrispondente con uno span per evidenziare
		return originalText.Substring(0, startPos) +
		       $"<span class=\"highlight\">{matchedText}</span>" +
		       originalText.Substring(endPos + 1);
	}

	private string GetOriginalText(int textIndex)
	{
        // Implementa questo metodo per restituire il testo originale basato sull'indice
        // Potrebbe essere necessario passare i testi originali come parametri aggiuntivi
        // o memorizzarli in una proprietà della classe
		return textIndex == 0 ? MyInputText1 : MyInputText2;
	}
}